#! /usr/bin/env python2.7

"""
Designs primers to amplify genes, possibly in multiple amplicons per gene.  If multiple amplicons, will avoid positions with N bases, so if you pass it a hard-masked genome fasta file, it should avoid known repetition regions.
 -- Weronika Patena, 2014
"""

# standard library
from __future__ import division
import sys
import math
from string import maketrans

def define_option_parser():
    """ Populates and returns an optparse option parser object, with __doc__ as the usage string."""
    from optparse import OptionParser
    parser = OptionParser(__doc__)

    ### functionality options
    parser.add_option('-g', '--genome_file', metavar='F', default='Creinhardtii_236_softmasked.fa', 
                      help="Location of chlamy genome fasta file (don't use a hard-masked one) (default %default).")
    parser.add_option('-G', '--gene_position_file', metavar='F', default='Creinhardtii_236_gene.txt', 
                      help="Location of file giving gene positions, generated by convert_gff_gene_data.py (default %default).")
    parser.add_option('-a', '--max_amplicon_size', type='int', default=4000, metavar='N',
                      help="Maximum desired amplicon size - larger genes will be split into multiple amplicons (default %default)")
    parser.add_option('-m', '--min_amplicon_size', type='int', default=300, metavar='N', 
                      help="Minimum amplicon size - the only smaller amplicons will be if the whole gene is smaller (default %default)")
    parser.add_option('-o', '--overlap_size', type='int', default=30, metavar='N',
                      help="Desired overlap between multiple amplicons per gene (default %default)")
    parser.add_option('-F', '--output_file', default='output.txt', metavar='N',
                      help="Output file (including path if not in this directory) (default %default)")
    return parser

def parse_fasta(infile, not_standard_nucleotides=False):
    """ Usage: for (header,seq) in parse_fasta(infile): <do stuff>."""
    header,seq = '',''
    for line in open(infile):
        # DON'T skip empty lines - there may be empty sequences in the file!
        #if not line.strip():    continue
        # if you find a header line, start a new entry, first yielding the previous entry
        # (unless there is no previous entry, i.e no header, since a sequence can be empty)
        if line and line[0]=='>':
            if header:   
                yield (header,seq)
            header = line[1:].strip()      # line[1:] to get rid of the initial >
            seq = ''
        # otherwise it's a seq line - add it to the current sequence (strip spaces/newlines)
        else: 
            seq += line.strip()
            # exit with an error if the file doesn't parse right! (illegal seq characters or a no-header sequence)
            #   (maketrans('','') is an empty table - all I'm doing here is using the second argument to delete characters.
            #   in python 2.6+ I can use None instead for the same effect, but this should make it run in 2.5.)
            if not not_standard_nucleotides and line.strip().upper().translate(maketrans('',''),'ACTGURYKMSWBDHVN .-*'): 
                raise Exception("Error: invalid sequence line! %s"%line)
                # TODO shouldn't really hard-code the allowed bases...
                # MAYBE-TODO include option for proteins to check those?  And maybe an option for just ACTG?
            if not header: 
                raise Exception("Error: Found a sequence line without a header first! %s"%line)
    if type(input)==file:    input.close()
    # also return the last entry, if it's non-empty!
    if header:
        yield (header,seq)

def Complement(Sequence):
    """ Sean Blum's code - Takes an input DNA string and returns the complement.  """
    Sequence=Sequence.upper()
    Trans=maketrans('ACTG','TGAC')
    return Sequence.translate(Trans)

def design_primers(Seq):
    """ Sean Blum's code - designs two primers to amplify seq, matching their TM. """
    Seq = Seq.upper()
    FStop=12
    RStop=-12
    Forward=Seq[:FStop+1]
    Reverse=Complement(Seq[:RStop-1:-1])
    Cf=Forward.count('C')
    Gf=Forward.count('G')
    Cr=Reverse.count('C')
    Gr=Reverse.count('G')
    FTm=64.9+41*(sum([Cf,Gf])-16.4)/len(Forward)
    RTm=64.9+41*(sum([Cr,Gr])-16.4)/len(Reverse)
    while FTm<58:
        FStop+=1
        Forward+=Seq[FStop]
        Cf=Forward.count('C')
        Gf=Forward.count('G')
        FTm=64.9+41*(sum([Cf,Gf])-16.4)/len(Forward)
    while RTm<58:
        RStop-=1
        Reverse+=Complement(Seq[RStop])
        Cr=Reverse.count('C')
        Gr=Reverse.count('G')
        RTm=64.9+41*(sum([Cr,Gr])-16.4)/len(Reverse)
    return [Forward,Reverse]
    
def parse_gene_text_file(infile):
    """ Parses file generated by convert_gff_gene_data.py, returns gene:(chromosome, strand, start, end, list_of_exon_start_end_tuples) dict. """
    gene_data = {}
    for line in open(infile):
        fields = line.strip().split('\t')
        ID, chrom, strand, start, end = fields[:5]
        CDS_positions = []
        for f in fields[5:]:
            exon_start, exon_end = f.split('-')
            CDS_positions.append((int(exon_start), int(exon_end)))
        gene_data[ID] = (chrom, strand, int(start), int(end), CDS_positions)
    return gene_data

if __name__=='__main__':
    parser = define_option_parser()
    options, args = parser.parse_args()
    if args:
        parser.print_help()
        sys.exit("\nError: The program doesn't understand these extra arguments! " + ', '.join(args))

    genome_seq = dict(parse_fasta(options.genome_file))
    gene_data = parse_gene_text_file(options.gene_position_file)
    min_real_amplicon_size, max_real_amplicon_size, max_amplicons_per_gene = options.max_amplicon_size, 0, 0
    N_total_amplicons = 0
    check_for_Ns = max(30, options.overlap_size)
    with open(options.output_file, 'w') as OUTFILE:
        N_short_genes, N_intron_junctions = 0, 0 
        OUTFILE.write('gene chromosome gene_position gene_length total_amplicons amplicon_N amplicon_position amplicon_len primerF primerR\n'.replace(' ','\t'))
        for gene, (chrom, strand, gene_start, gene_end, list_of_exon_start_end_tuples) in gene_data.items():
            # we don't want to include the stop codon, so change start or end depending on the direction
            if strand == '+':   gene_end -= 3
            else:               gene_start += 3
            gene_length = gene_end-gene_start+1
            if gene_length < options.min_amplicon_size: 
                N_short_genes += 1
            # now split the gene into amplicons if needed
            outfile_lines = []
            remaining_gene_length = gene_length
            start_position = gene_start
            while start_position < gene_end:
                # if the first amplicon can cover the whole gene, it shoulc
                if start_position + options.max_amplicon_size >= gene_end:
                    end_position = gene_end
                # otherwise put it in an exon that's between the min and max exon size AND leaves enough length for the next amplicon
                else:
                    max_end_position = min(start_position + options.max_amplicon_size, 
                                           gene_end - options.min_amplicon_size + options.overlap_size)
                    # grab the exons that are within the acceptable range for the end of the amplicon
                    valid_exons = [ (exon_start, exon_end) for (exon_start, exon_end) in list_of_exon_start_end_tuples 
                                    if exon_end > start_position + options.min_amplicon_size
                                    and exon_start < max_end_position - options.overlap_size ] 
                    # pick the exon that makes the largest amplicon below the max; pick end position within it
                    if valid_exons:
                        best_exon = max(valid_exons)
                        end_position = min(max_end_position, best_exon[1])
                    # if no exons, just pick a position
                    else:
                        #print "Gene %s has no valid exons for amplicon in position %s-%s - putting junction in intron!"%( gene, start_position, max_end_position)
                        N_intron_junctions += 1
                        end_position = max_end_position
                # grab actual amplicon seq, design primers:
                # start,end are 1-based and with end being the actual end and not the base after, so subtract 1 from start
                # primers are based on genome seq, so swap reverse/forward if gene is -strand
                amplicon_seq = genome_seq[chrom][start_position-1:end_position]
                primerF, primerR = design_primers(amplicon_seq)
                if strand=='-': 
                    primerF, primerR = primerR, primerF
                # save line (will print it later, once we know the total number of amplicons for this gene)
                outfile_lines.append([gene, chrom, "%s-%s"%(gene_start, gene_end), str(gene_length), 
                                      "%s-%s"%(start_position, end_position), str(len(amplicon_seq)), primerF, primerR])
                # setup for the next amplicon
                if end_position == gene_end:    start_position = gene_end
                else:                           start_position = end_position - options.overlap_size
                min_real_amplicon_size = min(min_real_amplicon_size, len(amplicon_seq))
                max_real_amplicon_size = max(max_real_amplicon_size, len(amplicon_seq))
            # now print outfile lines for this gene, including the final total number of amplicons and amplicon numbers;
            # if gene is -strand, reverse the order, so that the first amplicon first primer always starts with the start codon!
            N_amplicons = len(outfile_lines)
            N_total_amplicons += N_amplicons
            max_amplicons_per_gene = max(max_amplicons_per_gene, N_amplicons)
            if strand=='-': 
                outfile_lines.reverse()
            for N, outfile_line in enumerate(outfile_lines):
                OUTFILE.write('\t'.join(outfile_line[:4] + [str(N_amplicons), str(N+1)] + outfile_line[4:] ) + '\n')
            if not outfile_lines[0][6][:3] == 'ATG':
                gene_seq = genome_seq[chrom][gene_start-1:gene_end].upper()
                if strand == '-':   
                    gene_seq = Complement(gene_seq)
                    if not gene_seq.startswith('ATG'):
                        print "Warning: gene %s doesn't start with ATG!"%gene
                    else:
                        print "ERROR: gene %s starts with ATG, but its first amplicon first primer doesn't!"%gene

    print "DONE! Designed primers for %s genes, with a total of %s amplicons; 1-%s amplicons per gene; amplicon sizes are %s-%sbp."%(len(gene_data), N_total_amplicons, max_amplicons_per_gene, min_real_amplicon_size, max_real_amplicon_size)
    print "Details on iffy cases: %s genes were smaller than the min amplicon size, and there were %s cases where it was impossible to put a junction in an exon while staying within the amplicon size ranges, so it was placed in an intron."%(N_short_genes, N_intron_junctions)
